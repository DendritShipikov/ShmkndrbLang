

g := (x) -> x * x;

f := (x, y) -> g(x) + g(y);

F := (a) -> ( (x) -> x * a );

f := (n) -> if n = 0 then 1 else n * self(n - 1);

h := (x, y) -> a * b where a := x + y, b := x - y;

Object:
  Integer
  Function
  Builtin

g := (x) -> x * x - 1;

Если разрешить доступ по имени, то теряем однозначность:
  g := x -> x * x;
  f := x, y -> g(x) + g(y); // x * x + y * y;
  g := x -> x; // f изменилась (побочный эффект)

Если во время создания функции сделать копирование из списка захвата,
то проблема неоднозначности решается, 
но нельзя по простому записать косвенную рекурисю.
Ну и хрен с ней.
Косвенную рекурсию можно в этом случае сделать путём передачи функциональной переменной:
  even := odd, n -> if n = 0 then 1 else odd(self, n - 1);
  odd := even, n -> if n = 0 then 0 else even(self, n - 1);

Теперь к вопросу о самом теле функции. Можно компилить в байткод (просто), можно строить дерево и его исполнять (сложнее).


  


